#!/usr/bin/env python3"""This script aggregates ATAC peak counts from individual cells into a MEX matrix.Arguments-----------sample_name (optional)    Name to be used as prefix for output files--cov_dir    Path to directory containing coverage files generated by quantify_peaks_counts.sh--min_detected_fragments (optional)    Minimum number of total fragments a cell must have to be kept    Default = 500--min_detected_peaks (optional)    Minimum number of peaks a cell must have to be kept    Default = 500"""### ---------------------------------------- ###def parse_args():        ### Sample name        if '--sample_name' in argv:                sample_name = argv[argv.index('--sample_name') + 1]        else:                sample_name = 'atac'        ### Filtering variables        # Minimum number of fragments a cell must have to be kept        if '--min_detected_fragments' in argv:                min_detected_fragments = int(argv[argv.index('--min_detected_fragments') + 1])        else:                min_detected_fragments = 500        # Minimum number of peaks a cell must have to be kept        if '--min_detected_peaks' in argv:                min_detected_peaks = int(argv[argv.index('--min_detected_peaks') + 1])        else:                min_detected_peaks = 500        ### Coverage directory        cov_dir = argv[argv.index('--cov_dir') + 1]        cells_cov_files = [f'{cov_dir}/{file}' for file in listdir(cov_dir) if file.endswith('.cov.gz')]        return sample_name, min_detected_fragments, min_detected_peaks, cells_cov_files### ---------------------------------------- ###def parse_cov_files(cov_files, min_fragments=500, min_peaks=500):        # Init features list        features = pd.read_csv(cov_files[0], sep='\t', header=None).iloc[:, :3]        features.columns = ['contig', 'start', 'end']        features = (features['contig'] + ':' + features['start'].astype(str) + '-' + features['end'].astype(str)).values        # Init sparse matrix        cells_num, peaks_num = len(cov_files), features.shape[0]    sparse_matrix = dok_matrix((cells_num, peaks_num), dtype=int)    # Parse data        barcodes = []        for n,cv in enumerate(cov_files):                if (n + 1) % 100 == 0 and n > 0:                        print(f'Processed {n + 1} / {cells_num} cells', end='\r')                try:                    counts = pd.read_csv(cv, sep='\t', header=None).iloc[:, -1].values                except:            continue        if (counts > 0).sum() >= min_peaks and counts.sum() >= min_fragments:                    sparse_matrix[len(barcodes), :] = counts                        barcodes.append(cv.split('/')[-1].replace('.cov.gz', ''))    sparse_matrix = sparse_matrix[:len(barcodes),]        # Convert to csr_matrix    sparse_matrix = csr_matrix(sparse_matrix)        return features, barcodes, sparse_matrix### ---------------------------------------- ###def save_sparse_matrix_to_path(main_path, label, barcodes, features, matrix, save_mtx=True, max_cells_in_memory=10000):        # Saves a sparse matrix in nzip and 10X Genomics format to a desired path after preprocessing    # N.B. 10X Genomics mtx matrix is saved only if save_mtx = True    # N.B. The 10X Genomics format was chosen since it's quite human readable and can easily be    # imported in R Seurat if one desires        # Create dir to store sparse matrix    out_dir, count = f'{label}', 0    while out_dir in listdir(main_path):                count += 1        out_dir = f'{label}_{count}'        makedirs(f'{main_path}/{out_dir}')        # Save barcodes    out_text = ('\n'.join(barcodes)).encode()    with gzip.open(f'{main_path}/{out_dir}/{label}_barcodes.tsv.gz', 'wb') as output:                output.write(out_text)        # Save features    out_text = ('\n'.join(features)).encode()    with gzip.open(f'{main_path}/{out_dir}/{label}_features.tsv.gz', 'wb') as output:                output.write(out_text)        # Save matrix as npz    save_npz(f'{main_path}/{out_dir}/{label}_matrix.mtx.npz', matrix, compressed=True)    # Save matrix as 10X Genomics mtx file    if save_mtx:            csr_to_mtx(matrix, out_name=f'{main_path}/{out_dir}/{label}_matrix.mtx.gz', max_cells=max_cells_in_memory)        return f'{main_path}/{out_dir}'### ---------------------------------------- ###def csr_to_mtx(csr, out_name, max_cells=1000):        # Save csr_matrix as 10X Genomics mtx file (100 cells at a time to save memory)    with gzip.open(out_name, 'wb') as mtx_out:                for i in range(csr.shape[0] // max_cells + 1):                        # Creating indexes for mtx rows (genes) and columns (cells)            # Note that in the csr, rows and columns are transposed            cols, rows = np.where(csr[i * max_cells : (i + 1) * max_cells].toarray() != 0)            cols += i * max_cells + 1                        # Get values            counts = csr[i * max_cells : (i + 1) * max_cells].toarray().flatten()                        # Format text            out_text = '\n'.join([f'{r}\t{c}\t{n}' for r, c, n in zip(rows, cols, counts)])            out_text = out_text.encode()                        if i > 0 and i < csr.shape[0] // max_cells:                                out_text += b'\n'                        # Write text            mtx_out.write(out_text)            ### ------------------MAIN------------------ ###import gzipimport numpy as npimport pandas as pdfrom os import listdir, makedirsfrom scipy.sparse import csr_matrix, dok_matrix, save_npzfrom sys import argv### Parse args and load datasample_name, min_detected_fragments, min_detected_peaks, cells_cov_files = parse_args()### Create sparse count matrixfeatures, barcodes, sparse_matrix = parse_cov_files(cells_cov_files, min_detected_fragments, min_detected_peaks)### Statsfinal_cell_num, final_peaks_num = sparse_matrix.shapeprint(f'{sample_name}: {final_cell_num} cells and {final_peaks_num} peaks')### Save matrixsave_location = save_sparse_matrix_to_path('./', sample_name, barcodes, features, sparse_matrix, save_mtx=True)